import{_ as d,c as a,a2 as s,o as e}from"./chunks/framework.DPuwY6B9.js";const m=JSON.parse('{"title":"探索x86汇编调试：寄存器与基本指令操作实战","description":"","frontmatter":{},"headers":[],"relativePath":"major/thoughts/探索x86汇编调试：寄存器与基本指令操作实战.md","filePath":"major/thoughts/探索x86汇编调试：寄存器与基本指令操作实战.md"}'),i={name:"major/thoughts/探索x86汇编调试：寄存器与基本指令操作实战.md"};function n(r,t,p,l,h,o){return e(),a("div",null,t[0]||(t[0]=[s(`<h1 id="探索x86汇编调试-寄存器与基本指令操作实战" tabindex="-1">探索x86汇编调试：寄存器与基本指令操作实战 <a class="header-anchor" href="#探索x86汇编调试-寄存器与基本指令操作实战" aria-label="Permalink to &quot;探索x86汇编调试：寄存器与基本指令操作实战&quot;">​</a></h1><p>intel-8086-asm-basic</p><h2 id="_1-进入debug模式" tabindex="-1">1.进入debug模式 <a class="header-anchor" href="#_1-进入debug模式" aria-label="Permalink to &quot;1.进入debug模式&quot;">​</a></h2><p><img src="https://img.imotao.com/i/2024/03/20/65fa8c1498454.png" alt="截屏2024-03-20 15.08.24"></p><p><code>r</code> 查看</p><h2 id="_2-mov指令测试" tabindex="-1">2. mov指令测试 <a class="header-anchor" href="#_2-mov指令测试" aria-label="Permalink to &quot;2. mov指令测试&quot;">​</a></h2><p>指令以<code>CS:IP</code> 格式进行读取，后跟8086 asm实际指令：</p><p><img src="https://img.imotao.com/i/2024/03/20/65fa8c90538d1.png" alt="截屏2024-03-20 15.12.43"></p><p>可以看到，当我们再次“唤醒” <code>CS:IP</code> 时，光标停留在上次指令结束的地方。</p><p><img src="https://img.imotao.com/i/2024/03/20/65fa8d5e256a6.png" alt="截屏2024-03-20 15.16.04"></p><p><code>IP</code> 偏移，不知道这么说对不对，每次改变为“ <strong>2</strong> ”。</p><p>测试代码如下：</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">; 设置当前 AX=0008，BX=0008，IP=0107</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ah</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">13</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">; 输出为上图：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">; AX=1308，BX=0013，IP=010B</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="_3-add指令测试" tabindex="-1">3. add指令测试 <a class="header-anchor" href="#_3-add指令测试" aria-label="Permalink to &quot;3. add指令测试&quot;">​</a></h2><p><img src="https://img.imotao.com/i/2024/03/20/65fa8f675bcab.png" alt="截屏2024-03-20 15.25.18"></p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">; 测试 add 指令</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> bx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ax</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cx</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bx</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><img src="https://img.imotao.com/i/2024/03/20/65fa8fd6d3999.png" alt="截屏2024-03-20 15.27.05"></p><h2 id="_4-sub指令测试" tabindex="-1">4. sub指令测试 <a class="header-anchor" href="#_4-sub指令测试" aria-label="Permalink to &quot;4. sub指令测试&quot;">​</a></h2><p>小tips：超出四位，或者超出两位，都会直接舍掉。 进行计算验证的时候，可以使用计算器程序员模式来进行检验，这个macOS 和 Windows下都有。</p><p><img src="https://img.imotao.com/i/2024/03/20/65fa9319cb6d7.png" alt="截屏2024-03-20 15.40.55"></p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">; 测试sub指令操作两个寄存器相减</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">sub</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bx</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="_5-关于越界以下进行说明" tabindex="-1">5. 关于越界以下进行说明： <a class="header-anchor" href="#_5-关于越界以下进行说明" aria-label="Permalink to &quot;5. 关于越界以下进行说明：&quot;">​</a></h2><p><img src="https://img.imotao.com/i/2024/03/20/65fa93e8b671f.png" alt="截屏2024-03-20 15.44.15"></p><p>多余进位会直接舍掉，这里<code>bl</code> 就是这个道理，计算结果为<code>F2</code> 。</p><p><img src="https://img.imotao.com/i/2024/03/20/65fa95add1e7c.png" alt="截屏2024-03-20 15.51.55"></p><h2 id="_6-小插曲-在mac-m1-上跑-docker-brew🍺" tabindex="-1">6. 小插曲： 在mac m1 上跑 docker brew🍺 <a class="header-anchor" href="#_6-小插曲-在mac-m1-上跑-docker-brew🍺" aria-label="Permalink to &quot;6. 小插曲： 在mac m1 上跑 docker  brew🍺&quot;">​</a></h2><p>现在是2024年，docker已经支持 AppleSilicon，可以直接 brew🍺就行：<a href="https://formulae.brew.sh/formula/docker" target="_blank" rel="noreferrer">https://formulae.brew.sh/formula/docker</a></p><p>docker image地址：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>https://hub.docker.com/r/jeremiedevelops/easy-masm</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>有个项目是在 mac m1上简单跑 masm，晚上试了下docker，好麻烦，不如 dosbox-x 来的直接。</p><h2 id="_7-寄存器表" tabindex="-1">7.寄存器表 <a class="header-anchor" href="#_7-寄存器表" aria-label="Permalink to &quot;7.寄存器表&quot;">​</a></h2><p>通用寄存器、特殊用途寄存器和段寄存器的x86汇编寄存器对照表：</p><table tabindex="0"><thead><tr><th>简写</th><th>中文名称</th><th>英文全称</th><th>说明</th></tr></thead><tbody><tr><td>AX</td><td>累加器</td><td>Accumulator</td><td>16位通用寄存器</td></tr><tr><td>BX</td><td>基址寄存器</td><td>Base Register</td><td>16位通用寄存器</td></tr><tr><td>CX</td><td>计数器</td><td>Counter Register</td><td>16位通用寄存器</td></tr><tr><td>DX</td><td>数据寄存器</td><td>Data Register</td><td>16位通用寄存器</td></tr><tr><td>SI</td><td>源变址寄存器</td><td>Source Index Register</td><td>16位通用寄存器</td></tr><tr><td>DI</td><td>目的变址寄存器</td><td>Destination Index Register</td><td>16位通用寄存器</td></tr><tr><td>BP</td><td>基址指针寄存器</td><td>Base Pointer Register</td><td>16位通用寄存器</td></tr><tr><td>SP</td><td>堆栈指针寄存器</td><td>Stack Pointer Register</td><td>16位通用寄存器</td></tr><tr><td>AL</td><td>累加器的低8位</td><td>Accumulator Low</td><td>8位通用寄存器</td></tr><tr><td>AH</td><td>累加器的高8位</td><td>Accumulator High</td><td>8位通用寄存器</td></tr><tr><td>BL</td><td>基址寄存器的低8位</td><td>Base Low</td><td>8位通用寄存器</td></tr><tr><td>BH</td><td>基址寄存器的高8位</td><td>Base High</td><td>8位通用寄存器</td></tr><tr><td>CL</td><td>计数器的低8位</td><td>Counter Low</td><td>8位通用寄存器</td></tr><tr><td>CH</td><td>计数器的高8位</td><td>Counter High</td><td>8位通用寄存器</td></tr><tr><td>DL</td><td>数据寄存器的低8位</td><td>Data Low</td><td>8位通用寄存器</td></tr><tr><td>DH</td><td>数据寄存器的高8位</td><td>Data High</td><td>8位通用寄存器</td></tr><tr><td>EAX</td><td>扩展累加器</td><td>Extended Accumulator</td><td>32位通用寄存器</td></tr><tr><td>EBX</td><td>扩展基址寄存器</td><td>Extended Base</td><td>32位通用寄存器</td></tr><tr><td>ECX</td><td>扩展计数器</td><td>Extended Counter</td><td>32位通用寄存器</td></tr><tr><td>EDX</td><td>扩展数据寄存器</td><td>Extended Data</td><td>32位通用寄存器</td></tr><tr><td>ESI</td><td>扩展源变址寄存器</td><td>Extended Source Index</td><td>32位通用寄存器</td></tr><tr><td>EDI</td><td>扩展目的变址寄存器</td><td>Extended Destination Index</td><td>32位通用寄存器</td></tr><tr><td>EBP</td><td>扩展基址指针寄存器</td><td>Extended Base Pointer</td><td>32位通用寄存器</td></tr><tr><td>ESP</td><td>扩展堆栈指针寄存器</td><td>Extended Stack Pointer</td><td>32位通用寄存器</td></tr><tr><td>RAX</td><td>高位扩展累加器</td><td>Extended Accumulator</td><td>64位通用寄存器</td></tr><tr><td>RBX</td><td>高位扩展基址寄存器</td><td>Extended Base</td><td>64位通用寄存器</td></tr><tr><td>RCX</td><td>高位扩展计数器</td><td>Extended Counter</td><td>64位通用寄存器</td></tr><tr><td>RDX</td><td>高位扩展数据寄存器</td><td>Extended Data</td><td>64位通用寄存器</td></tr><tr><td>RSI</td><td>高位扩展源变址寄存器</td><td>Extended Source Index</td><td>64位通用寄存器</td></tr><tr><td>RDI</td><td>高位扩展目的变址寄存器</td><td>Extended Destination Index</td><td>64位通用寄存器</td></tr><tr><td>RBP</td><td>高位扩展基址指针寄存器</td><td>Extended Base Pointer</td><td>64位通用寄存器</td></tr><tr><td>RSP</td><td>高位扩展堆栈指针寄存器</td><td>Extended Stack Pointer</td><td>64位通用寄存器</td></tr><tr><td>RIP</td><td>指令指针寄存器</td><td>Instruction Pointer</td><td>存储当前执行指令的地址</td></tr><tr><td>FLAGS</td><td>标志寄存器</td><td>Flags Register</td><td>存储CPU的状态信息</td></tr><tr><td>CS</td><td>代码段寄存器</td><td>Code Segment Register</td><td>存储代码段的起始地址</td></tr><tr><td>DS</td><td>数据段寄存器</td><td>Data Segment Register</td><td>存储数据段的起始地址</td></tr><tr><td>SS</td><td>堆栈段寄存器</td><td>Stack Segment Register</td><td>存储堆栈段的起始地址</td></tr><tr><td>ES</td><td>附加段寄存器</td><td>Extra Segment Register</td><td>用于一般目的的附加数据段</td></tr><tr><td>FS</td><td>附加段寄存器</td><td>Extra Segment Register</td><td>用于一般目的的附加数据段</td></tr><tr><td>GS</td><td>附加段寄存器</td><td>Extra Segment Register</td><td>用于一般目的的附加数据段</td></tr></tbody></table><p>这些寄存器在x86汇编语言编程中起着重要作用，用于存储数据、地址、指令、状态信息等。</p><h2 id="_8-段-未完" tabindex="-1">8. 段(未完) <a class="header-anchor" href="#_8-段-未完" aria-label="Permalink to &quot;8. 段(未完)&quot;">​</a></h2><p><img src="https://img.imotao.com/i/2024/03/21/65fbb1da7ecd1.png" alt="截屏2024-03-21 12.03.48"></p><p>执行前3条指令：</p><ul><li>ax=1000</li><li>ss=1000</li><li>sp=0020</li></ul><p><img src="https://img.imotao.com/i/2024/03/21/65fbb2322e077.png" alt="截屏2024-03-21 12.05.49"></p><p>执行后2条指令：</p><ul><li>ax=0DAB (cs=0DAB)</li><li>ds=0DAB</li></ul><p><img src="https://img.imotao.com/i/2024/03/21/65fbb41f69511.png" alt="截屏2024-03-21 12.14.13"></p><p>然后：</p><div class="language-asm vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">asm</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">mov</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ax</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]         </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">; [0]处的字型数据送入ax</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">; ah=20</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">; al=CD</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://img.imotao.com/i/2024/03/21/65fbb53e9b096.png" alt="截屏2024-03-21 12.18.58"></p><p>总之，段是我们自己定义的。一个段可以是数据段DS，也可以是栈段SS。</p><table tabindex="0"><thead><tr><th style="text-align:left;">DS</th><th>数据段寄存器</th><th>Data Segment Register</th><th>存储数据段的起始地址</th></tr></thead><tbody><tr><td style="text-align:left;">SS</td><td>堆栈段寄存器</td><td>Stack Segment Register</td><td>存储堆栈段的起始地址</td></tr></tbody></table><hr><p><strong>更新于</strong>：2024年3月21日</p>`,49)]))}const k=d(i,[["render",n]]);export{m as __pageData,k as default};
