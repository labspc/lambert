import{_ as e,c as r,a4 as t,o}from"./chunks/framework.DUbUI6ZK.js";const m=JSON.parse('{"title":"读yinwang博客有感：编程语言设计、类型系统与函数式编程","description":"","frontmatter":{},"headers":[],"relativePath":"major/thoughts/读yinwang博客有感：编程语言设计、类型系统与函数式编程.md","filePath":"major/thoughts/读yinwang博客有感：编程语言设计、类型系统与函数式编程.md"}'),n={name:"major/thoughts/读yinwang博客有感：编程语言设计、类型系统与函数式编程.md"};function i(l,a,s,h,c,g){return o(),r("div",null,a[0]||(a[0]=[t('<h1 id="读yinwang博客有感-编程语言设计、类型系统与函数式编程" tabindex="-1">读yinwang博客有感：编程语言设计、类型系统与函数式编程 <a class="header-anchor" href="#读yinwang博客有感-编程语言设计、类型系统与函数式编程" aria-label="Permalink to &quot;读yinwang博客有感：编程语言设计、类型系统与函数式编程&quot;">​</a></h1><p>本文仅作为入门篇学习笔记。</p><ul><li>PL/PLT</li><li>Type System</li><li>FP</li></ul><hr><blockquote><p>IT 业人士经常混淆编程语言（PL）和编译器两个领域，而其实 PL 和编译器是很不一样的。真懂 PL 的人去做编译器也会比较顺手，而编译器专业的却不一定懂 PL。为什么呢？因为 PL 研究涵盖了计算最本质的原理，它不但能解释语言的语义，而且能解释处理器的构架和工作原理。当然它也能解释编译器是怎么回事，因为编译器只不过是把一种语言的语义，利用另外一种语言表达出来，也就是翻译一下。PL 研究所用的编程范式和技巧，很多可以用到编译器的构造中去，但却比编译器的范畴广阔很多。 <a href="https://www.yinwang.org/blog-cn/2019/12/24/compilers" target="_blank" rel="noreferrer">https://www.yinwang.org/blog-cn/2019/12/24/compilers</a></p></blockquote><hr><h2 id="个人学习经历" tabindex="-1">个人学习经历 <a class="header-anchor" href="#个人学习经历" aria-label="Permalink to &quot;个人学习经历&quot;">​</a></h2><p><strong>注意⚠️</strong>：本文聊 PL、Type、FP 本来就是敏感话题，这只是学习笔记。因为这几个领域都是很深的，我都不太懂，只能简单提提概念，不敢妄言。FP 我之前有花时间去关注，去学习，下面我想说说自己的观点：</p><ul><li>不要一上来就大谈 FP 的思想，从代码细节去着手，去讲解</li><li>不要一上来就聊各种“行业黑话”，讲一堆名词，对新人极其不友好</li><li>不要一上来就大谈 FP 的历史</li></ul><p>引用：</p><blockquote><p>用Racket好，相当于scheme的超集， 兼具scheme的简洁和common LISP的实用， 自带一个超好用的IDE，在你写代码的时候自动做语法检查，确保你不会迷失在括号的波涛中</p><p>最近想学一门lisp，请问common lisp好呢还是scheme好？ - 知乎 <a href="https://www.zhihu.com/question/31038057/answer/65676920" target="_blank" rel="noreferrer">https://www.zhihu.com/question/31038057/answer/65676920</a></p></blockquote><p>我有学过半个月的Racket语言，感觉很有意思(别的我也有浅浅试试，还是Racket舒服，纯个人喜好)。 在这之前我也断断续续关注过FP，最终还是选择了Racket，可以现在去阅读本文后面的资源部分，PKU开设的这门课程就很不错。</p><p>在自学的过程中，我有看 @winter 老师在B站发的视频，也看了YouTube上的一些视频，但是个人对 <strong>柯里化(Curry 化) 、Lambda 演算</strong> 等概念还是搞不清。</p><p>Lambda表达式 我在 Python 中也会用，这里不知道说的对不对。我个人理解是，如果对很多概念实在看不懂，可以找到具体的 Example 读读，<strong>我个人理解是 Lambda 演算就是为了在代码中更好的去表达。</strong> FP的一些基础概念、理论对我来说确实很难，但是有这么一个了解的过程，<strong>我对FP现在已经“去魅”，收获还是有的。</strong></p><p><strong>Lambda演算</strong> <code>f(x)</code> 是在干什么？ <strong>定义函数</strong> 理解有限我只能理解到这一层，欢迎留言讨论。</p><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>编程语言设计（PL）作为计算机科学中的重要分支，涉及计算本质的理解。语言的设计不仅仅是编译器的实现，而是基于语言语义的本质来探索计算的根本。要真正理解一门编程语言的设计，必须熟悉编程语言理论（PLT）以及类型系统等核心概念。本文将从编程语言设计、类型系统的作用、函数式编程以及逻辑式编程的不同之处出发，探讨如何入门 PL 领域。</p><h2 id="编程语言设计与编译器实现的区别" tabindex="-1">编程语言设计与编译器实现的区别 <a class="header-anchor" href="#编程语言设计与编译器实现的区别" aria-label="Permalink to &quot;编程语言设计与编译器实现的区别&quot;">​</a></h2><p>编程语言设计与编译器实现通常被混淆，但二者有着本质的区别。<strong>编程语言设计着眼于理解计算的基本原理，研究如何有效表达计算过程</strong>。编译器实现则更侧重于把一种语言的高层语义翻译成另一种语言，例如机器代码。编程语言设计师的职责在于定义语言规范，而<strong>编译器实现者则依照规范实现具体的编译功能</strong>。</p><h2 id="类型系统的重要性" tabindex="-1">类型系统的重要性 <a class="header-anchor" href="#类型系统的重要性" aria-label="Permalink to &quot;类型系统的重要性&quot;">​</a></h2><p>类型系统在编程语言中确保程序的一致性与安全性，它通过对数据进行分类（如整数、字符串等），检测类型相关的错误。类型理论是编程语言理论中的一个关键领域，通过对类型系统的理解，可以帮助设计更安全、健壮的编程语言。深入研究类型系统不仅帮助理解编程语言的设计，还能提升对编译器的优化能力。</p><h2 id="函数式编程的核心价值" tabindex="-1">函数式编程的核心价值 <a class="header-anchor" href="#函数式编程的核心价值" aria-label="Permalink to &quot;函数式编程的核心价值&quot;">​</a></h2><p>在编程语言设计中，函数式编程（FP）占有一席之地。FP关注不可变数据和函数的纯粹性(<strong>在SICP中有提到FP</strong>)，<strong>这种范式可以帮助减少副作用</strong>、增强代码可读性。虽然 PL 的学习中不必深入研究逻辑式编程，但函数式编程则值得一探。学习 Scheme 或 Racket 是个不错的选择，因为它们都提供了丰富的函数式编程实践机会。</p><h2 id="从scheme到racket" tabindex="-1">从Scheme到Racket <a class="header-anchor" href="#从scheme到racket" aria-label="Permalink to &quot;从Scheme到Racket&quot;">​</a></h2><p>虽然 Scheme 和 Racket 的核心相似，但 Racket 更加现代，工具链也更加友好。Racket 的丰富库和文档，使其成为学习函数式编程的理想选择。同时，可以探索 miniKanren 和 Prolog 之类的工具，这些工具在逻辑编程与约束求解中应用广泛。初学者可以通过 Racket 实现 miniKanren，以更直观地理解逻辑编程的概念。</p><h2 id="minikanren-与-prolog-的比较" tabindex="-1">miniKanren 与 Prolog 的比较 <a class="header-anchor" href="#minikanren-与-prolog-的比较" aria-label="Permalink to &quot;miniKanren 与 Prolog 的比较&quot;">​</a></h2><ul><li><strong>学习曲线</strong>：Prolog 作为逻辑编程语言的先驱，资料齐全，但上手难度较大。miniKanren 相对简化，适合初学者入门。</li><li><strong>应用场景</strong>：Prolog 在人工智能、自然语言处理等领域广泛应用，而 miniKanren 更适合作为逻辑编程的教学工具。</li><li><strong>资料与资源</strong>：两者都有充足的学习资源。Prolog 的经典教材较多，而 miniKanren 可以通过 Racket 的库直接体验到逻辑编程的原理和实践。</li></ul><h2 id="学习路线与建议" tabindex="-1">学习路线与建议 <a class="header-anchor" href="#学习路线与建议" aria-label="Permalink to &quot;学习路线与建议&quot;">​</a></h2><ol><li><strong>第一步</strong>：学习基础编程语言理论（PLT），理解计算的基本概念。</li><li><strong>第二步</strong>：掌握类型系统的基础知识，通过学习 Haskell 或 Racket 深入理解类型系统的作用。</li><li><strong>第三步</strong>：在掌握基础知识后，可以尝试实现一个简单的 Scheme 解释器，甚至构建一个小型编译器，以巩固对 PL 和编译器的理解。</li><li><strong>第四步</strong>：探索逻辑编程，通过 miniKanren 和 Prolog 学习基础的逻辑求解和约束编程概念。</li></ol><p><strong>PS：</strong> 上述学习方法来自AI，仅供参考。</p><h2 id="更多资源" tabindex="-1">更多资源 <a class="header-anchor" href="#更多资源" aria-label="Permalink to &quot;更多资源&quot;">​</a></h2><ul><li><a href="https://github.com/xiajava/books/blob/master/SICP/README.md" target="_blank" rel="noreferrer">https://github.com/xiajava/books/blob/master/SICP/README.md</a></li><li><a href="https://thzt.github.io/2016/01/29/computer-science/" target="_blank" rel="noreferrer">https://thzt.github.io/2016/01/29/computer-science/</a></li><li><a href="https://www.math.pku.edu.cn/teachers/qiuzy/progtech/" target="_blank" rel="noreferrer">https://www.math.pku.edu.cn/teachers/qiuzy/progtech/</a></li><li><a href="https://docs.racket-lang.org/quick/index.html" target="_blank" rel="noreferrer">https://docs.racket-lang.org/quick/index.html</a></li></ul><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>编程语言设计是一项深邃且需要长时间积累的研究领域。语言的设计并非易事，要真正理解其精髓，需要深入探索类型系统、函数式编程、逻辑编程等内容。通过这些学习，将会逐步理解“计算的本质是什么”这一核心问题。未来，还需更多学习和实践，以深入理解计算的更多面向，推动编程语言的发展和创新。</p><hr><p><strong>更新于</strong>：2023年11月30日</p>',36)]))}const u=e(n,[["render",i]]);export{m as __pageData,u as default};
